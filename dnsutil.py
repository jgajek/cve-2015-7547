#!/usr/bin/env python3

import struct

FLAGS = { "QR" : 0x8000,
          "AA" : 0x0400,
          "TC" : 0x0200,
          "RD" : 0x0100,
          "RA" : 0x0080,
          "Z"  : 0x0040,
          "AD" : 0x0020,
          "CD" : 0x0010 }

OPCODE = { "QUERY"  : 0,
           "IQUERY" : 1,
           "STATUS" : 2,
           "NOTIFY" : 4,
           "UPDATE" : 5 }

OPCODE_STR = { 0 : "QUERY",
               1 : "IQUERY",
               2 : "STATUS",
               4 : "NOTIFY",
               5 : "UPDATE" }

RCODE = { "NOERROR"  : 0,
          "FORMERR"  : 1,
          "SERVFAIL" : 2,
          "NXDOMAIN" : 3,
          "NOTIMP"   : 4,
          "REFUSED"  : 5,
          "YXDOMAIN" : 6,
          "XRRSET"   : 7,
          "NOTAUTH"  : 8,
          "NOTZONE"  : 9 }

RCODE_STR = { 0 : "NOERROR",
              1 : "FORMERR",
              2 : "SERVFAIL",
              3 : "NXDOMAIN",
              4 : "NOTIMP",
              5 : "REFUSED",
              6 : "YXDOMAIN",
              7 : "XRRSET",
              8 : "NOTAUTH",
              9 : "NOTZONE" }

TYPE = { "A"     : 1,
         "NS"    : 2,
         "CNAME" : 5,
         "SOA"   : 6,
         "NULL"  : 10,
         "PTR"   : 12,
         "MX"    : 15,
         "TXT"   : 16,
         "AAAA"  : 28,
         "OPT"   : 41 }

TYPE_STR = { 1  : "A",
             2  : "NS",
             5  : "CNAME",
             6  : "SOA",
             10 : "NULL",
             12 : "PTR",
             15 : "MX",
             16 : "TXT",
             28 : "AAAA",
             41 : "OPT" }

CLASS = { "IN" : 1 }

CLASS_STR = { 1 : "IN" }


def listify(p):
    return [p] if isinstance(p, str) else p


class DNSValueError(Exception):
    pass

class DNSParseError(Exception):
    pass


class DNSFlags(object):

    @staticmethod
    def from_bytes(data):
        """Converts a sequence of network-ordered bytes into a DNSFlags object"""
        if len(data) < 2:
            raise DNSParseError("Not enough data to parse flags")

        return DNSFlags(*struct.unpack("!H", data))

    def __init__(self, flags = 0):
        """Constructs a DNSFlags instance"""
        self.flags = flags

        if flags & FLAGS["Z"]:
            raise DNSValueError("Reserved flag not zero")

        if self.opcode() not in OPCODE_STR:
            raise DNSValueError("Invalid opcode value")

        if self.rcode() not in RCODE_STR:
            raise DNSValueError("Invalid rcode value")

    def bytes(self):
        """Converts a DNSFlags object into a sequence of network-ordered bytes"""
        return struct.pack("!H", self.flags)

    def set(self, flags):
        """Sets one or more flags"""
        for f in listify(flags):
            self.flags |= FLAGS.get(f, 0)

    def clear(self, flags):
        """Clears one or more flags"""
        for f in listify(flags):
            self.flags &= ~FLAGS.get(f, 0)

    def set_opcode(self, opcode):
        """Sets the OPCODE field"""
        self.flags &= ~(0b1111 << 11)
        self.flags |= OPCODE.get(opcode, 0) << 11

    def opcode(self):
        """Returns the OPCODE value"""
        return (self.flags >> 11) & 0b1111

    def opcode_str(self):
        """Return the OPCODE string"""
        return OPCODE_STR.get(self.opcode(), "?")

    def set_rcode(self, rcode):
        """Sets the RCODE field"""
        self.flags &= ~0b1111
        self.flags |= RCODE.get(rcode, 0)

    def rcode(self):
        """Returns the RCODE value"""
        return self.flags & 0b1111

    def rcode_str(self):
        """Returns the RCODE string"""
        return RCODE_STR.get(self.rcode(), "?")

    def flags_int(self):
        """Returns the entire flags field as an integer"""
        return self.flags

    def flags_str(self):
        """Pretty-prints the flags"""
        flags = [f for f in FLAGS if self.flags & FLAGS[f]]
        return "[{}]".format(" ".join(flags))


class DNSHeader(object):

    @staticmethod
    def from_bytes(data):
        """Converts a sequence of network-ordered bytes into a DNSHeader object"""
        if len(data) < 12:
            raise DNSParseError("Not enough data to parse header")

        return DNSHeader(*struct.unpack("!HHHHHH", data))

    def __init__(self, ID, flags, qdcount, ancount, nscount, arcount):
        """Constructs a DNSHeader instance"""
        self.ID = ID
        if isinstance(flags, DNSFlags):
            self.flags = flags
        else:
            self.flags = DNSFlags(flags)
        self.qdcount = qdcount
        self.ancount = ancount
        self.nscount = nscount
        self.arcount = arcount

    def bytes(self):
        """Converts a DNSHeader object into a sequence of network-ordered bytes"""
        return struct.pack("!HHHHHH", self.ID, self.flags.flags_int(), self.qdcount,
                           self.ancount, self.nscount, self.arcount)

    def __str__(self):
        """Pretty-prints the header"""
        return "ID {} {} {} {} QD {} AN {} NS {} AR {}".format(hex(self.ID),
                                                               self.flags.opcode_str(),
                                                               self.flags.flags_str(),
                                                               self.flags.rcode_str(),
                                                               self.qdcount, self.ancount,
                                                               self.nscount, self.arcount)

    def __repr__(self):
        return self.__str__()


class DNSQuestion(object):

    def __init__(self, labels, qtype, qclass):
        """Constructs a DNSQuestion instance"""
        self.labels = labels
        self.qtype = qtype
        self.qclass = qclass

    def bytes(self):
        """Converts a DNSQuestion object into a sequence of network-ordered bytes"""
        return (b"".join([bytes([len(a)]) + a for a in self.labels]) + b"\x00" +
                struct.pack("!HH", self.qtype, self.qclass))

    def __str__(self):
        """Pretty-prints the question"""
        return "{} {} {}".format(CLASS_STR.get(self.qclass, self.qclass),
                                 TYPE_STR.get(self.qtype, self.qtype),
                                 ".".join([a.decode("ascii") for a in self.labels]))

    def __repr__(self):
        return self.__str__()


class DNSRR(object):

    def __init__(self, labels, rtype, rclass, ttl, rdlength, rdata):
        """Constructs a DNSRR instance"""
        self.labels = labels
        self.rtype = rtype
        self.rclass = rclass
        self.ttl = ttl
        self.rdlength = rdlength
        self.rdata = rdata

    def bytes(self):
        """Converts a DNSRR object into a sequence of network-ordered bytes"""
        if self.rtype == 2 or self.rtype == 5 or self.rtype == 12:
            rdata = b"".join([bytes([len(a)]) + a for a in self.rdata]) + b"\x00"
        elif self.rtype == 15:
            rdata = (struct.pack("!H", self.rdata[0]) +
                     b"".join([bytes([len(a)]) + a for a in self.rdata[1]]) + b"\x00")
        else:
            rdata = self.rdata

        return (b"".join([bytes([len(a)]) + a for a in self.labels]) + b"\x00" +
                struct.pack("!HHLH", self.rtype, self.rclass, self.ttl, len(rdata)) +
                rdata)

    def __str__(self):
        """Pretty-prints the RR"""
        rname = ".".join([a.decode("ascii") for a in self.labels])
        rtype = TYPE_STR.get(self.rtype, self.rtype)
        rclass = CLASS_STR.get(self.rclass, self.rclass)
        rttl = self.ttl
        rdlength = self.rdlength

        if rtype == "A":
            if rdlength == 4:
                rdata = ".".join([str(self.rdata[i]) for i in range(4)])
            else:
                rdata = "?"

            return "{} {} {} {} [{}] {}".format(rclass, rtype, rname, rttl, rdlength, rdata)

        if rtype == "AAAA":
            if rdlength == 16:
                rdata = ":".join(["{:02x}".format(self.rdata[i]) for i in range(16)])
            else:
                rdata = "?"

            return "{} {} {} {} [{}] {}".format(rclass, rtype, rname, rttl, rdlength, rdata)

        if rtype == "NS" or rtype == "CNAME" or rtype == "PTR":
            rdata = ".".join([a.decode("ascii") for a in self.rdata])

            return "{} {} {} {} [{}] {}".format(rclass, rtype, rname, rttl, rdlength, rdata)

        if rtype == "MX":
            mxpri = self.rdata[0]
            mxname = ".".join([a.decode("ascii") for a in self.rdata[1]])

            return "{} {} {} {} [{}] ({}) {}".format(rclass, rtype, rname, rttl, rdlength, mxpri, mxname)

        if rtype == "OPT":
            udpmax = self.rclass

            return "{} UDP MAX {}".format(rtype, udpmax)

        # Default output format
        return "{} {} {} {} [{}]".format(rclass, rtype, rname, rttl, rdlength)


    def __repr__(self):
        return self.__str__()


class DNSMessage(object):

    def __init__(self, header, questions, answers, authorities, additionals):
        """Constructs a DNSMessage instance"""
        self.header = header
        self.questions = questions
        self.answers = answers
        self.authorities = authorities
        self.additionals = additionals

    def bytes(self):
        """Converts a DNSMessage object into a sequence of network-ordered bytes"""
        return (self.header.bytes() +
                b"".join([q.bytes() for q in self.questions]) +
                b"".join([a.bytes() for a in self.answers]) +
                b"".join([a.bytes() for a in self.authorities]) +
                b"".join([a.bytes() for a in self.additionals]))

    def __str__(self):
        """Pretty-prints the message"""
        output = str(self.header)

        if self.questions:
            output += "\n  QUESTIONS:\n    " + "\n    ".join([str(q) for q in self.questions])
        if self.answers:
            output += "\n  ANSWERS:\n    " + "\n    ".join([str(a) for a in self.answers])
        if self.authorities:
            output += "\n  AUTHORITY:\n    " + "\n    ".join([str(a) for a in self.authorities])
        if self.additionals:
            output += "\n  ADDITIONAL:\n    " + "\n    ".join([str(a) for a in self.additionals])
        return output

    def __repr__(self):
        return self.__str__()


class DNSParser(object):

    @staticmethod
    def parse_label(data):
        """Parse an uncompressed label"""
        if len(data) < 1 or len(data) < data[0] + 1:
            raise DNSParseError("Not enough data to parse label")

        if data[0] > 63:
            raise DNSParseError("Label exceeds maximum allowed length")

        return data[0] + 1, data[1 : data[0] + 1]

    @staticmethod
    def parse_pointer(data):
        """Parse a label pointer"""
        if len(data) < 2:
            raise DNSParseError("Not enough data to parse label pointer")

        return 2, struct.unpack("!H", data[0:2])[0] & ~0xc000

    @staticmethod
    def parse_name(data, fulldata):
        """Parse a set of labels and label pointers"""
        if len(data) < 1:
            raise DNSParseError("Not enough data to parse name")

        labels = []
        pos = 0
        pointer = False

        while data[pos] != 0:
            if data[pos] >= 0xc0:
                # Parse label pointer
                pointer = True
                add, offset = DNSParser.parse_pointer(data[pos:])
                tmp, label = DNSParser.parse_label(fulldata[offset:])
                labels.append(label)
                pos += add
                break
            else:
                # Parse label
                add, label = DNSParser.parse_label(data[pos:])
                labels.append(label)
                pos += add

                if len(data) <= pos:
                    raise DNSParseError("Not enough data to parse name")

        if not pointer:
            pos += 1

        return pos, labels

    @staticmethod
    def parse_question(data, fulldata):
        """Parse a question"""
        pos, labels = DNSParser.parse_name(data, fulldata)

        if len(data) < pos + 4:
            raise DNSParseError("Not enough data to parse question")

        qtype, qclass = struct.unpack("!HH", data[pos : pos + 4])

        return pos + 4, DNSQuestion(labels, qtype, qclass)

    @staticmethod
    def parse_rr(data, fulldata):
        """Parse a resource record"""
        pos, labels = DNSParser.parse_name(data, fulldata)

        if len(data) < pos + 10:
            raise DNSParseError("Not enough data to parse resource record")

        rtype, rclass, ttl, rdlength = struct.unpack("!HHLH", data[pos : pos + 10])

        if len(data) < pos + 10 + rdlength:
            raise DNSParseError("Not enough data to parse resource record")

        # Special handling for NS, CNAME, PTR data
        if rtype == 2 or rtype == 5 or rtype == 12:
            tmp, rdata = DNSParser.parse_name(data[pos + 10 : pos + 10 + rdlength], fulldata)
        # Special handling for MX data
        elif rtype == 15:
            pri = struct.unpack("!H", data[pos + 10 : pos + 12])[0]
            tmp, rdata = DNSParser.parse_name(data[pos + 12 : pos + 10 + rdlength], fulldata)
            rdata = (pri, rdata)
        else:
            rdata = data[pos + 10 : pos + 10 + rdlength]

        return pos + 10 + rdlength, DNSRR(labels, rtype, rclass, ttl, rdlength, rdata)

    @staticmethod
    def parse_message(data):
        """Parse a DNS message"""
        questions = []
        answers = []
        authorities = []
        additionals = []

        if len(data) < 12:
            raise DNSParseError("Not enough data to parse message")

        header = DNSHeader.from_bytes(data[:12])
        pos = 12

        for i in range(header.qdcount):
            add, question = DNSParser.parse_question(data[pos:], data)
            questions.append(question)
            pos += add

        for i in range(header.ancount):
            add, answer = DNSParser.parse_rr(data[pos:], data)
            answers.append(answer)
            pos += add

        for i in range(header.nscount):
            add, authority = DNSParser.parse_rr(data[pos:], data)
            authorities.append(authority)
            pos += add

        for i in range(header.arcount):
            add, additional = DNSParser.parse_rr(data[pos:], data)
            additionals.append(additional)
            pos += add

        return pos, DNSMessage(header, questions, answers, authorities, additionals)

